using System;
using System.Collections;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using static System.Math;
using System.Runtime.InteropServices;
using DataTools.MathTools;
using DataTools.Text;
using static DataTools.Text.TextTools;


namespace DataTools.Extras
{

    /// <summary>
    /// Unit value type converter.
    /// </summary>
    /// <remarks></remarks>
    public class UnitValueTypeConverter : DecimalConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {

            if (sourceType == typeof(string))
                return true;
            else if (sourceType.IsPrimitive)
                return true;

            return
                base.CanConvertFrom(context, sourceType);
        }

        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType)
        {
            if (destType == typeof(string))
                return true;
            else if (destType.IsPrimitive)
                return true;
            return base.CanConvertTo(context, destType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            var uv = new UnitValue();

            if (value.GetType() == typeof(string))
            {
                uv.Parse((string)value);
                return uv;
            }
            else if (IsNumber(value))
            {
                uv.Value = (double)value;
                uv.Unit = "px";

                return uv;
            }

            return base.ConvertFrom(context, culture, value);
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            UnitValue uv = (UnitValue)value;

            if (destinationType == typeof(string))
            {
                return value.ToString();
            }
            else if (destinationType.IsPrimitive)
            {
                return uv.Value;
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }

    /// <summary>
    /// Represents a Value in a given unit or compound unit.
    /// </summary>
    /// <remarks></remarks>
    [TypeConverter(typeof(UnitValueTypeConverter))]
    public struct UnitValue
    {

        /// <summary>
        /// The value of the measurement.
        /// </summary>
        /// <remarks></remarks>
        public double Value;

        /// <summary>
        /// The string representation of the unit or compound unit of the measurement.
        /// </summary>
        /// <remarks></remarks>
        public string Unit;

        /// <summary>
        /// Represents the internal metric info.
        /// </summary>
        /// <remarks></remarks>
        private MetricInfo info;


        /// <summary>
        /// Parse the contents structure into a formal unit/value string.
        /// </summary>
        /// <returns></returns>
        /// <remarks></remarks>
        public override string ToString()
        {
            MetricTool.Parse(Value + Unit, ref info);
            Unit = info.ShortName;
            Value = info.Value;
            return info.ShortFormat;
        }

        /// <summary>
        /// Parse a new value.
        /// </summary>
        /// <param name="value"></param>
        /// <remarks></remarks>
        public void Parse(string value)
        {
            MetricTool.Parse(value, ref info, "", true);
            Unit = info.ShortName;
            Value = info.Value;
        }

        public MetricInfo GetDetails()
        {
            return info;
        }

        #region String CType Operators

        public static implicit operator string(UnitValue operand)
        {
            return operand.ToString();
        }

        public static explicit operator UnitValue(string operand)
        {
            var u = new UnitValue();
            u.Parse(operand);
            return u;
        }

        #endregion

        #region Numeric CType Operators

        public static UnitValue NumberToUnitValue(double operand)
        {
            var u = new UnitValue();
            MetricTool.Parse(operand + "px", ref u.info);
            u.Unit = u.info.ShortName;
            u.Value = u.info.Value;
            return u;
        }

        public static implicit operator long(UnitValue operand)
        {
            return (int)Round(operand.Value);
        }

        public static explicit operator UnitValue(long operand)
        {
            return NumberToUnitValue(operand);
        }

        public static implicit operator int(UnitValue operand)
        {
            return (int)Round(operand.Value);
        }

        public static explicit operator UnitValue(int operand)
        {
            return NumberToUnitValue(operand);
        }

        public static implicit operator short(UnitValue operand)
        {
            return (short)(int)Round(operand.Value);
        }

        public static explicit operator UnitValue(short operand)
        {
            return NumberToUnitValue(operand);
        }

        public static implicit operator double(UnitValue operand)
        {
            return (int)Round(operand.Value);
        }

        public static explicit operator UnitValue(double operand)
        {
            return NumberToUnitValue(operand);
        }

        // Public Shared Widening Operator CType(operand As MetricTool.UnitValue) As Double
        // Return CInt(operand.Value)
        // End Operator

        // Public Shared Narrowing Operator CType(operand As Double) As MetricTool.UnitValue
        // Return NumberToUnitValue(CDbl(operand))
        // End Operator

        #endregion

        #region Equality Operators

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            UnitValue u = (UnitValue)obj;
            if (u.Value != Value)
                return false;
            if ((u.Unit ?? "") != (Unit ?? ""))
                return false;
            return true;
        }

        public static bool operator ==(UnitValue operand1, UnitValue operand2)
        {
            return operand1.Equals(operand2);
        }

        public static bool operator !=(UnitValue operand1, UnitValue operand2)
        {
            return !operand1.Equals(operand2);
        }

        #endregion

    }

    [TypeConverter(typeof(ExpandableObjectConverter))]
    public class MetricUnit : ICloneable
    {
        private string measures = "";

        public string Measures
        {
            get
            {
                return measures;
            }
            set
            {
                measures = TitleCase(value);
            }
        }

        private string name = "";

        public string Name
        {
            get
            {
                return name;
            }

            set
            {
                name = TitleCase(value);
            }
        }

        private string prefix = "";

        public string Prefix
        {
            get
            {
                return prefix;
            }

            set
            {
                prefix = value;
            }
        }

        private string pluralName = "";

        public string PluralName
        {
            get
            {
                return pluralName;
            }

            set
            {
                pluralName = TitleCase(value);
            }
        }

        // ' Indicates this is a base unit to which all other units in this category convert
        private bool isBase = false;

        public bool IsBase
        {
            get
            {
                return isBase;
            }

            set
            {
                isBase = value;
            }
        }

        // ' for derived bases.  $ is used to denote a variable.
        private string modifies = "";

        public string Modifies
        {
            get
            {
                return modifies;
            }

            set
            {
                modifies = TitleCase(value);
            }
        }

        private double multiplier = 0.0d;

        public double Multiplier
        {
            get
            {
                return multiplier;
            }

            set
            {
                multiplier = value;
            }
        }

        private double offset = 0.0d;

        public double Offset
        {
            get
            {
                return offset;
            }

            set
            {
                offset = value;
            }
        }

        private bool offsetFirst = false;

        public bool OffsetFirst
        {
            get
            {
                return offsetFirst;
            }

            set
            {
                offsetFirst = value;
            }
        }

        // ' Set to True for derived bases with equations.

        private bool derived = false;

        public bool Derived
        {
            get
            {
                return derived;
            }

            set
            {
                derived = value;
            }
        }

        // ' Equation for derived bases.  $ is used to denote a variable.

        private string equation = "";

        public string Equation
        {
            get
            {
                return equation;
            }

            set
            {
                equation = value;
            }
        }

        public object Clone()
        {
            return MemberwiseClone();
        }

        public override string ToString()
        {
            return PluralName + " (" + Measures + ")";
        }
    }

    [TypeConverter(typeof(ExpandableObjectConverter))]
    public class MetricInfo : ICloneable
    {
        private double _Value;

        public double Value
        {
            get
            {
                return _Value;
            }

            set
            {
                _Value = value;
            }
        }

        private double _BaseValue;

        public double BaseValue
        {
            get
            {
                return _BaseValue;
            }

            set
            {
                _BaseValue = value;
            }
        }

        private double _Multiplier;

        public double Multiplier
        {
            get
            {
                return _Multiplier;
            }

            set
            {
                _Multiplier = value;
            }
        }

        private string _BaseUnit;

        public string BaseUnit
        {
            get
            {
                return _BaseUnit;
            }

            set
            {
                _BaseUnit = value;
            }
        }

        private string _Name;

        public string Name
        {
            get
            {
                return _Name;
            }

            set
            {
                _Name = value;
            }
        }

        private string _PluralName;

        public string PluralName
        {
            get
            {
                return _PluralName;
            }

            set
            {
                _PluralName = value;
            }
        }

        private string _ShortName;

        public string ShortName
        {
            get
            {
                return _ShortName;
            }

            set
            {
                _ShortName = value;
            }
        }

        private string _Measures;

        public string Measures
        {
            get
            {
                return _Measures;
            }

            set
            {
                _Measures = value;
            }
        }

        private string _Format;

        public string Format
        {
            get
            {
                return _Format;
            }

            set
            {
                _Format = value;
            }
        }

        private string _ShortFormat;

        public string ShortFormat
        {
            get
            {
                return _ShortFormat;
            }

            set
            {
                _ShortFormat = value;
            }
        }

        private MetricUnit _Unit = new MetricUnit();

        public MetricUnit Unit
        {
            get
            {
                return _Unit;
            }

            set
            {
                _Unit = value;
            }
        }

        public override string ToString()
        {
            return _Unit.ToString() + " " + _Value;
        }

        public object Clone()
        {
            MetricInfo objNew = (MetricInfo)MemberwiseClone();
            objNew.Unit = (MetricUnit)_Unit.Clone();
            return objNew;
        }
    }


    /// <summary>
    /// General, all-purpose unit conversion class.
    /// </summary>
    /// <remarks></remarks>
    public class MetricTool
    {


        public static readonly string[] Prefixes = new string[] { "", "deci", "centi", "milli", "micro", "nano", "pico", "femto", "atto", "zepto", "yocto", "deca", "hecto", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi" };
        public static readonly string[] ShortPrefixes = new string[] { "", "d", "c", "m", "μ", "n", "p", "f", "a", "z", "y", "da", "h", "k", "M", "G", "T", "P", "E", "Z", "Y", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei", "Zi", "Yi" };
        public static readonly double[] Multipliers = new double[] { Pow(10d, 0d), Pow(10d, -1), Pow(10d, -2), Pow(10d, -3), Pow(10d, -6), Pow(10d, -9), Pow(10d, -12), Pow(10d, -15), Pow(10d, -18), Pow(10d, -21), Pow(10d, -24), Pow(10d, 1d), Pow(10d, 2d), Pow(10d, 3d), Pow(10d, 6d), Pow(10d, 9d), Pow(10d, 12d), Pow(10d, 15d), Pow(10d, 18d), Pow(10d, 21d), Pow(10d, 24d), Pow(2d, 10d), Pow(2d, 20d), Pow(2d, 30d), Pow(2d, 40d), Pow(2d, 50d), Pow(2d, 60d), Pow(2d, 70d), Pow(2d, 80d) };

        private static int roundingDigits = 4;

        private MetricInfo info = new MetricInfo();
        private string convert;
        private bool longFormat = true;
        private MetricInfo[] convIn;
        private MetricInfo[] convOut;
        private UnitCollection myUnits;

        private static UnitCollection units = new UnitCollection();

        [Browsable(true)]
        public static UnitCollection Units
        {
            get
            {
                return units;
            }
        }

        [Browsable(true)]
        public MetricInfo[] ConversionQuery
        {
            get
            {
                return convIn;
            }
            set
            {
                convIn = value;
            }
        }

        [Browsable(true)]
        public MetricInfo[] ConversionResult
        {
            get
            {
                return convOut;
            }
            set
            {
                convOut = value;
            }
        }

        [Browsable(true)]
        public bool LongFormat
        {
            get
            {
                return longFormat;
            }
            set
            {
                longFormat = value;
                MetricInfo[] argInputInfo = null;
                MetricInfo[] argOutputInfo = null;
                Convert(Query, InputInfo: ref argInputInfo, OutputInfo: ref argOutputInfo);
                Format = Format;
            }
        }

        [Browsable(true)]
        public static int RoundingDigits
        {
            get
            {
                return roundingDigits;
            }
            set
            {
                roundingDigits = value;
            }
        }

        [Browsable(true)]
        public UnitCollection AvailableUnits
        {
            get
            {
                if (myUnits is null)
                    return units;
                return myUnits;
            }
            set
            {
                myUnits = value;
            }
        }

        [Browsable(true)]
        public string Format
        {
            get
            {
                if (longFormat == true)
                {
                    return info.Format;
                }
                else
                {
                    return info.ShortFormat;
                }
            }

            set
            {
                Parse(value, ref info);
            }
        }

        public MetricInfo ApplyEquation(MetricUnit u, ref string ErrorText, params double[] vars)
        {
            int i;
            int c;
            int j;

            string s = u.Equation;
            string v;

            MetricInfo objInfo = null;

            c = vars.Length;

            var loopTo = c;

            for (i = 0; i <= loopTo; i++)
            {
                v = "$" + (i + 1);
                j = s.IndexOf(v);
                if (j == -1)
                {
                    ErrorText = "Missing variable " + v + " in equation, or too many parameters passed.";
                    return null;
                }

                while (j != -1)
                    s = s.Replace(v, "" + vars[i]);
            }

            j = s.IndexOf("$");
            if (j != -1)
            {
                ErrorText = "Too few parameters passed.";
                return null;
            }

            var p = new MathExpressionParser();
            if (p.ParseOperations(s) == false)
            {
                ErrorText = p.ErrorText;
                return null;
            }

            s = "" + p.Value + u.Name;
            Parse(s, ref objInfo);
            return objInfo;
        }

        /// <summary>
        /// Discerns whether or not a value is an x per y (or x/y) value and returns the parsed contents.
        /// </summary>
        /// <param name="value">Value string to analyze.</param>
        /// <param name="MustMeasure">Imperitive measurement units array.  The string must match this many units of these exact types to parse correctly.</param>
        /// <returns>Parsed MetricInfo array.</returns>
        /// <remarks></remarks>
        public MetricInfo[] IsPer(string value, MetricInfo[] MustMeasure = null, bool parseMath = true)
        {
            string[] s;
            int i = 0;
            MetricInfo[] m = null;
            bool boo = false;
            string[] perScan;
            if (parseMath)
            {
                perScan = new[] { "per" };
            }
            else
            {
                perScan = new[] { "per", "/" };
            }

            foreach (var pp in perScan)
            {
                if (value.IndexOf(pp) != -1)
                {
                    s = Split(value, pp);
                    m = new MetricInfo[s.Length];
                    var loopTo = s.Length - 1;
                    for (i = 0; i <= loopTo; i++)
                    {
                        m[i] = new MetricInfo();
                        s[i] = s[i].Trim();
                        if (i != 0)
                        {
                            if (FVal(s[i]) == 0)
                                s[i] = "1" + s[i];
                        }

                        if (MustMeasure is null)
                        {
                            Parse(s[i], ref m[i]);
                        }
                        else if (i <= MustMeasure.Length - 1)
                            Parse(s[i], ref m[i], MustMeasure[i].Measures);
                    }

                    boo = true;
                }
            }

            if (!boo)
            {
                m = new[] { new MetricInfo() };
                if (MustMeasure is null)
                {
                    Parse(value, ref m[0]);
                }
                else if (i <= MustMeasure.Length - 1)
                    Parse(value, ref m[0], MustMeasure[i].Measures);
            }

            return m;
        }

        public bool ComparePer(MetricInfo[] m1, MetricInfo[] m2)
        {
            int i;
            if (m1.Length != m2.Length)
                return false;
            var loopTo = m1.Length - 1;
            for (i = 0; i <= loopTo; i++)
            {
                if ((m1[i].Measures ?? "") != (m2[i].Measures ?? ""))
                {
                    convert = "Cannot convert between " + Separate(m1[i].Measures) + " and " + Separate(m2[i].Measures) + ".";
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Get or set the conversion query.
        /// </summary>
        /// <returns></returns>
        public string Query
        {
            get
            {
                return convert;
            }

            set
            {
                MetricInfo[] argInputInfo = null;
                MetricInfo[] argOutputInfo = null;
                Convert(value, InputInfo: ref argInputInfo, OutputInfo: ref argOutputInfo);
            }
        }

        /// <summary>
        /// Returns the value in the current unit.
        /// </summary>
        /// <returns></returns>
        [Browsable(true)]
        public double Value
        {
            get
            {
                return info.Value;
            }
        }

        /// <summary>
        /// Returns the <see cref="MetricInfo"/> object.
        /// </summary>
        /// <returns></returns>
        [Browsable(true)]
        public MetricInfo Info
        {
            get
            {
                return info;
            }

            set
            {
                info = value;
            }
        }

        public double Convert(MetricInfo inputValue, string outputType, ref MetricInfo outputValue)
        {
            string s = inputValue.BaseValue + inputValue.BaseUnit + "=" + outputType;
            MetricInfo[] argInputInfo = null;
            MetricInfo[] argOutputInfo = null;
            Convert(s, InputInfo: ref argInputInfo, OutputInfo: ref argOutputInfo);
            outputValue = (MetricInfo)convOut[0].Clone();
            return convOut[0].Value;
        }

        public double Convert(MetricInfo inputValue, MetricUnit outputType, ref MetricInfo outputValue)
        {
            string s = inputValue.BaseValue + inputValue.BaseUnit + "=" + outputType.Name;
            MetricInfo[] argInputInfo = null;
            MetricInfo[] argOutputInfo = null;
            Convert(s, InputInfo: ref argInputInfo, OutputInfo: ref argOutputInfo);
            outputValue = (MetricInfo)convOut[0].Clone();
            return convOut[0].Value;
        }

        public double Convert(MetricInfo inputValue, MetricUnit outputType)
        {
            string s = inputValue.BaseValue + inputValue.BaseUnit + "=" + outputType.Name;
            MetricInfo[] argInputInfo = null;
            MetricInfo[] argOutputInfo = null;
            Convert(s, InputInfo: ref argInputInfo, OutputInfo: ref argOutputInfo);
            return convOut[0].Value;
        }

        public double Convert(double inputValue, MetricUnit outputType)
        {
            string s = inputValue + "=" + outputType.Name;
            MetricInfo[] argInputInfo = null;
            MetricInfo[] argOutputInfo = null;
            Convert(s, InputInfo: ref argInputInfo, OutputInfo: ref argOutputInfo);
            return convOut[0].Value;
        }

        public double Convert(string inputValue, string outputType)
        {
            string s;
            s = inputValue + "=" + outputType;
            MetricInfo[] argInputInfo = null;
            MetricInfo[] argOutputInfo = null;
            Convert(s, InputInfo: ref argInputInfo, OutputInfo: ref argOutputInfo);
            return convOut[0].Value;
        }

        public double Convert(double inputValue, string inputType, string outputType = "px")
        {
            string s;
            s = "" + inputValue + inputType + "=" + outputType;
            MetricInfo[] argInputInfo = null;
            MetricInfo[] argOutputInfo = null;
            Convert(s, InputInfo: ref argInputInfo, OutputInfo: ref argOutputInfo);
            return convOut[0].Value;
        }

        /// <summary>
        /// Convert a series of unit representations into another form.
        /// For exmaple: 1 liter = gallons - or - 100 km/h = mi/h.  The answers will appear in the <see cref="MetricTool.Query">Query</see> variable.
        /// </summary>
        /// <param name="value">The string to parse.</param>
        /// <param name="InputInfo">The parsed detailed input value/unit array.</param>
        /// <param name="OutputInfo">The detailed output value/unit array.</param>
        /// <param name="parseMath">Specifies that the value string contains a mathematical equation.</param>
        /// <remarks></remarks>
        public void Convert(string value, [Optional, DefaultParameterValue(null)] ref MetricInfo[] InputInfo, [Optional, DefaultParameterValue(null)] ref MetricInfo[] OutputInfo, bool parseMath = true)
        {
            string[] s = null;
            int i;
            double v = 0.0d;
            double[] vv;
            MetricInfo[] i1;
            MetricInfo[] i2;
            if (string.IsNullOrEmpty(value))
                return;
            i = value.ToLower().IndexOf("convert ");
            if (i != -1)
            {
                value = value.Substring(i + 8).Trim();
            }

            if (value.IndexOf("=") == -1)
            {
                value = value.Replace(" to ", "=");
                value = value.Replace(" TO ", "=");
                value = value.Replace(" To ", "=");
                value = value.Replace(" is ", "=");
                value = value.Replace(" IS ", "=");
                value = value.Replace(" Is ", "=");
                value = value.Replace(" and ", "=");
                value = value.Replace(" AND ", "=");
                value = value.Replace(" And ", "=");
                value = value.Replace(" what ", "=");
                value = value.Replace(" WHAT ", "=");
                value = value.Replace(" What ", "=");
                value = value.Replace(" how many ", "=");
                value = value.Replace(" how much ", "=");
                value = value.Replace(" HOW MANY ", "=");
                value = value.Replace(" HOW MUCH ", "=");
                value = value.Replace(" How Many ", "=");
                value = value.Replace(" How Much ", "=");
                value = value.Replace("to to", "=");
                value = value.Replace("to to", "=");
            }

            value = OneSpace(value);
            if (value.IndexOf("=") != -1)
            {
                s = Split(value, "=");
            }
            else if (value.IndexOf(",") != -1)
            {
                s = Split(value, ",");
            }

            if (s is null)
                return;
            if (s.Length != 2)
                return;
            s[0] = s[0].Trim();
            if (!IsNumber(s[1]))
                s[1] = "1 " + s[1].Trim();
            i1 = IsPer(s[0], parseMath: parseMath);
            i2 = IsPer(s[1], i1, parseMath);
            if (ComparePer(i1, i2) == false)
                return;

            // If i2.Length >= 2 Then
            // For i = 1 To i2.Length - 1
            // Parse("" & i1(i).Value & i2(i).PluralName, i2(i))
            // Next
            // End If

            if (i1.Length == 1)
            {
                v = i1[0].BaseValue;
                {
                    var withBlock = i2[0].Unit;
                    if ((withBlock.Modifies ?? "") == (i1[0].BaseUnit ?? "") || (withBlock.Name ?? "") == (i1[0].BaseUnit ?? ""))
                    {
                        if ((withBlock.Name ?? "") == (i1[0].BaseUnit ?? ""))
                        {
                            v = i1[0].BaseValue;
                        }
                        else if (withBlock.OffsetFirst)
                        {
                            v /= withBlock.Multiplier;
                            v -= withBlock.Offset;
                        }
                        else
                        {
                            v -= withBlock.Offset;
                            v /= withBlock.Multiplier;
                        }
                    }

                    v /= i2[0].Multiplier;
                }

                v = Round(v, roundingDigits);
                Parse(v + " " + i2[0].Name, ref i2[0], i1[0].Measures, parseMath);
                if (longFormat)
                {
                    convert = "" + i1[0].Format + " is " + i2[0].Format;
                }
                else
                {
                    convert = "" + i1[0].ShortFormat + " is " + i2[0].ShortFormat;
                }
            }
            else
            {
                vv = new double[i1.Length];
                var loopTo = i1.Length - 1;
                for (i = 0; i <= loopTo; i++)
                {
                    vv[i] = i1[i].BaseValue;
                    {
                        var withBlock1 = i2[i].Unit;
                        if ((withBlock1.Modifies ?? "") == (i1[i].BaseUnit ?? "") || (withBlock1.Name ?? "") == (i1[i].BaseUnit ?? ""))
                        {
                            if ((withBlock1.Name ?? "") == (i1[i].BaseUnit ?? ""))
                            {
                                vv[i] = i1[i].BaseValue;
                            }
                            else if (withBlock1.OffsetFirst)
                            {
                                vv[i] /= withBlock1.Multiplier;
                                vv[i] -= withBlock1.Offset;
                            }
                            else
                            {
                                vv[i] -= withBlock1.Offset;
                                vv[i] /= withBlock1.Multiplier;
                            }
                        }

                        vv[i] /= i2[i].Multiplier;
                    }

                    if (Round(vv[i], roundingDigits) != 0d)
                        vv[i] = Round(vv[i], roundingDigits);
                    if (i == 0)
                    {
                        v = vv[i];
                    }
                    else
                    {
                        // i2(i).Value = 1
                        // If (i1(i).Value <> 0) Then vv(i) /= i1(i).Value
                        v /= vv[i];
                    }
                }

                v = Round(v, roundingDigits);
                convert = i1[0].Value.ToString("#,##0.####") + " ";
                var loopTo1 = i1.Length - 1;
                for (i = 0; i <= loopTo1; i++)
                {
                    if (longFormat)
                    {
                        if (i != 0)
                            convert += " per " + i1[i].Value.ToString("#,##0.####") + " ";
                        if (i1[i].Value != 1d)
                        {
                            convert += i1[i].PluralName;
                        }
                        else
                        {
                            convert += i1[i].Name;
                        }
                    }
                    else
                    {
                        if (i != 0)
                            convert += "/";
                        convert += i1[i].ShortName;
                    }
                }

                convert += " is ";
                convert += v.ToString("#,##0.####") + " ";
                i2[0].Value = v;
                var loopTo2 = i2.Length - 1;
                for (i = 0; i <= loopTo2; i++)
                {
                    if (longFormat)
                    {
                        if (i != 0)
                            convert += " per " + i2[i].Value.ToString("#,##0.####") + " ";
                        if (i2[i].Value != 1d)
                        {
                            convert += i2[i].PluralName;
                        }
                        else
                        {
                            convert += i2[i].Name;
                        }
                    }
                    else
                    {
                        if (i != 0)
                            convert += "/";
                        convert += i2[i].ShortName;
                    }
                }
            }

            ConversionQuery = i1;
            ConversionResult = i2;
            InputInfo = (MetricInfo[])i1.Clone();
            OutputInfo = (MetricInfo[])i2.Clone();
        }

        public static void WordsTest(string Example)
        {
            string[] s;
            s = Words(Example);
            Console.WriteLine("There are " + s.Length + " words, starting with " + s[0]);
        }

        public static double GetMultiplier(string prefix)
        {
            int i;
            int c;

            c = Prefixes.Length;


            if (prefix.Length <= 2)
            {
                for (i = 0; i < c; i++)
                {
                    if ((prefix ?? "") == (ShortPrefixes[i] ?? ""))
                    {
                        return Multipliers[i];
                    }
                }
            }

            prefix = prefix.ToLower();

            for (i = 0; i < c; i++)
            {
                if ((prefix ?? "") == (Prefixes[i] ?? ""))
                {
                    return Multipliers[i];
                }
            }

            // it's always safe to return 1
            return 1d;
        }

        public static double Parse(string value, ref MetricInfo info, string MustMeasure = "", bool parseMath = true)
        {
            MathExpressionParser mMath = default;
            MetricUnit[] arrUnits;

            bool markFail = false;

            char[] valueChars;

            int charLen;

            string[] arrStr;

            string textVar;

            double retVal;

            string procStr;
            string postProcStr;

            int n1;
            int n2 = 0;

            int i;
            int a, b, c;

            int x;
            int y;

            if (parseMath)
                mMath = new MathExpressionParser();
            
            if (MustMeasure is object)
                MustMeasure = MustMeasure.ToLower();
            
            if (info is null || info.Name is null)
            {
                info = new MetricInfo();
                if (string.IsNullOrEmpty(MustMeasure) == false)
                {
                    Parse(value, ref info, parseMath: parseMath);
                }
            }

            value = value.Trim();
            valueChars = value.ToCharArray();
            charLen = valueChars.Length - 1;

            if (string.IsNullOrEmpty(value))
                return 0d;

            if (parseMath == false)
            {
                while (!IsNumber(valueChars[charLen]))
                {
                    charLen -= 1;
                    if (charLen < 0)
                        break;
                }
            }
            else
            {
                while (!IsNumber(valueChars[charLen]) || (valueChars[charLen] == ')'))
                {
                    charLen -= 1;
                    if (charLen < 0)
                        break;
                }
            }

            if (charLen < 0)
                return default;
            
            procStr = value.Substring(charLen + 1).Trim();
            
            value = value.Substring(0, charLen + 1);
            
            i = 0;

            if (parseMath)
            {
                mMath.ParseOperations(value);
                retVal = mMath.Value;
            }
            else if (IsHex(value, ref i))
            {
                retVal = i;
            }
            else
            {
                retVal = FVal(value) ?? double.NaN;
            }

            if (procStr.Length > 1)
            {
                if (procStr.Substring(procStr.Length - 1) == ".")
                    procStr = procStr.Substring(0, procStr.Length - 1);
            }

            retVal = Round(retVal, roundingDigits);
            postProcStr = procStr.ToLower();
            
            info.Value = retVal;

            if (!string.IsNullOrEmpty(MustMeasure))
            {
                arrUnits = GetUnitsArray(MustMeasure);
            }
            else
            {
                arrUnits = Units.InnerArray;
            }

            if (arrUnits is null)
                return double.NaN;
            
            b = arrUnits.Length;
            
            for (n1 = 0; n1 < b; n1++)
            {
                if (string.IsNullOrEmpty(arrUnits[n1].Prefix))
                {
                    arrStr = new string[1];
                    arrStr[0] = "";
                }
                else
                {
                    arrStr = Split(arrUnits[n1].Prefix, ",");
                }

                a = ShortPrefixes.Length;

                for (n2 = 0; n2 < a; n2++)
                {
                    y = arrStr.Length;
                    
                    for (x = 0; x < y; x++)
                    {
                        arrStr[x] = arrStr[x].Trim();

                        textVar = ShortPrefixes[n2] + arrStr[x];

                        if ((procStr ?? "") == (textVar ?? "") | (procStr ?? "") == (textVar + "s" ?? ""))
                        {
                            if (string.IsNullOrEmpty(MustMeasure) | (MustMeasure ?? "") == (arrUnits[n1].Measures.ToLower() ?? ""))
                            {
                                info.ShortName = ShortPrefixes[n2] + arrStr[0];
                                info.Name = Prefixes[n2] + arrUnits[n1].Name;
                            
                                break;
                            }
                            // we found it!
                        }
                    }

                    if (x <= y)
                        break;
                }

                if (n2 < ShortPrefixes.Length)
                    break;

                c = Prefixes.Length;

                for (n2 = 0; n2 < c; n2++)
                {
                    textVar = Prefixes[n2] + arrUnits[n1].Name.ToLower();
                    if ((postProcStr ?? "") == (textVar ?? "") || (postProcStr ?? "") == (textVar + "s" ?? ""))
                    {
                        if (string.IsNullOrEmpty(MustMeasure) | (MustMeasure ?? "") == (arrUnits[n1].Measures.ToLower() ?? ""))
                        {
                            info.Name = textVar;
                            info.ShortName = ShortPrefixes[n2] + arrStr[0];
                            break;
                            // we found it!
                        }
                    }

                    textVar = Prefixes[n2] + arrUnits[n1].PluralName.ToLower();
                    if ((postProcStr ?? "") == (textVar ?? "") || (postProcStr ?? "") == (textVar + "s" ?? ""))
                    {
                        if (string.IsNullOrEmpty(MustMeasure) | (MustMeasure ?? "") == (arrUnits[n1].Measures.ToLower() ?? ""))
                        {
                            info.PluralName = textVar;
                            info.ShortName = ShortPrefixes[n2] + arrStr[0];
                            info.Name = Prefixes[n2] + arrUnits[n1].Name.ToLower();
                            break;
                            // we found it!
                        }
                    }
                }

                if (n2 < Prefixes.Length)
                    break;
            }

            if (n1 < Units.Count & n2 < Prefixes.Length)
            {
                info.Unit = arrUnits[n1];
                info.Multiplier = Multipliers[n2];
                info.BaseValue = info.Value * info.Multiplier;
                info.BaseUnit = arrUnits[n1].Name;
                info.Measures = arrUnits[n1].Measures;
                info.Format = "" + info.Value.ToString("#,##0.##") + " ";

                info.Name = TitleCase(info.Name);

                if (info.Value != 1d & !string.IsNullOrEmpty(arrUnits[n1].PluralName))
                {
                    info.Format += TitleCase(Prefixes[n2] + arrUnits[n1].PluralName.ToLower());
                }
                else
                {
                    info.Format += TitleCase(info.Name);
                }

                info.ShortFormat = "" + info.Value.ToString("#,##0.##") + " " + info.ShortName;

                if (!string.IsNullOrEmpty(arrUnits[n1].Modifies))
                {
                    if (arrUnits[n1].OffsetFirst == true)
                    {
                        info.BaseValue += arrUnits[n1].Offset;
                        info.BaseValue *= arrUnits[n1].Multiplier;
                    }
                    else
                    {
                        info.BaseValue *= arrUnits[n1].Multiplier;
                        info.BaseValue += arrUnits[n1].Offset;
                    }

                    info.BaseUnit = arrUnits[n1].Modifies;
                }

                if (!string.IsNullOrEmpty(arrUnits[n1].PluralName))
                {
                    if (string.IsNullOrEmpty(Prefixes[n2]))
                    {
                        info.PluralName = TitleCase(arrUnits[n1].PluralName);
                    }
                    else
                    {
                        info.PluralName = TitleCase(Prefixes[n2] + arrUnits[n1].PluralName.ToLower());
                    }
                }
            }

            if (markFail)
                return double.NaN;
            return info.Value;
        }

        public MetricTool(bool WithOwnUnits = false)
        {
            if (WithOwnUnits)
                myUnits = GetUnits();

            info.BaseValue = 0d;
            info.Multiplier = 1d;
            info.Value = 0d;
        }

        static MetricTool()
        {
            MetricUnit objUnit;
            objUnit = CreateUnit();
            
                ref var withBlock = ref objUnit;
                withBlock.Name = "liter";
                withBlock.PluralName = "liters";
                withBlock.Prefix = "L,litre,litres,ltr";
                withBlock.Measures = "volume";
                withBlock.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock1 = ref objUnit;
                withBlock1.Name = "gallon";
                withBlock1.PluralName = "gallons";
                withBlock1.Prefix = "gl,gal";
                withBlock1.Multiplier = 3.785411784d;
                withBlock1.Modifies = "liter";
                withBlock1.Measures = "volume";
            

            objUnit = CreateUnit();
            
                ref var withBlock2 = ref objUnit;
                withBlock2.Name = "cup";
                withBlock2.PluralName = "cups";
                withBlock2.Prefix = "cup";
                withBlock2.Multiplier = 0.2365882365d;
                withBlock2.Modifies = "liter";
                withBlock2.Measures = "volume";
            

            objUnit = CreateUnit();
            
                ref var withBlock3 = ref objUnit;
                withBlock3.Name = "tablespoon";
                withBlock3.PluralName = "tablespoons";
                withBlock3.Prefix = "tbsp";
                withBlock3.Multiplier = 0.01478676478125d;
                withBlock3.Modifies = "liter";
                withBlock3.Measures = "volume";
            

            objUnit = CreateUnit();
            
                ref var withBlock4 = ref objUnit;
                withBlock4.Name = "teaspoon";
                withBlock4.PluralName = "teaspoons";
                withBlock4.Prefix = "tsp";
                withBlock4.Multiplier = 0.00492892159375d;
                withBlock4.Modifies = "liter";
                withBlock4.Measures = "volume";
            

            objUnit = CreateUnit();
            
                ref var withBlock5 = ref objUnit;
                withBlock5.Name = "meter squared";
                withBlock5.PluralName = "meters squared";
                withBlock5.Prefix = "msq";
                withBlock5.Measures = "area";
                withBlock5.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock6 = ref objUnit;
                withBlock6.Name = "hectare";
                withBlock6.PluralName = "hectares";
                withBlock6.Prefix = "ha";
                withBlock6.Multiplier = 10000d;
                withBlock6.Modifies = "meter squared";
                withBlock6.Measures = "area";
            

            objUnit = CreateUnit();
            
                ref var withBlock7 = ref objUnit;
                withBlock7.Name = "acre";
                withBlock7.PluralName = "acres";
                withBlock7.Prefix = "ac";
                withBlock7.Multiplier = 4046.8564224d;
                withBlock7.Modifies = "meter squared";
                withBlock7.Measures = "area";
            

            objUnit = CreateUnit();
            
                ref var withBlock8 = ref objUnit;
                withBlock8.Name = "square foot";
                withBlock8.PluralName = "square feet";
                withBlock8.Prefix = "sqft,sft,ftsq";
                withBlock8.Multiplier = 0.09290304d;
                withBlock8.Modifies = "meter squared";
                withBlock8.Measures = "area";
            

            objUnit = CreateUnit();
            
                ref var withBlock9 = ref objUnit;
                withBlock9.Name = "square inch";
                withBlock9.PluralName = "square inches";
                withBlock9.Prefix = "insq,sqin";
                withBlock9.Multiplier = 0.00064516d;
                withBlock9.Modifies = "meter squared";
                withBlock9.Measures = "area";
            

            objUnit = CreateUnit();
            
                ref var withBlock10 = ref objUnit;
                withBlock10.Name = "square mile";
                withBlock10.PluralName = "square miles";
                withBlock10.Prefix = "misq,sqmi,sqm";
                withBlock10.Multiplier = 2589.9d;
                withBlock10.Modifies = "meter squared";
                withBlock10.Measures = "area";
            

            objUnit = CreateUnit();
            
                ref var withBlock11 = ref objUnit;
                withBlock11.Name = "quart";
                withBlock11.PluralName = "quarts";
                withBlock11.Prefix = "qt";
                withBlock11.Multiplier = 0.946352946d;
                withBlock11.Modifies = "liter";
                withBlock11.Measures = "volume";
            

            objUnit = CreateUnit();
            
                ref var withBlock12 = ref objUnit;
                withBlock12.Name = "pint";
                withBlock12.PluralName = "pints";
                withBlock12.Prefix = "p";
                withBlock12.Multiplier = 0.473176473d;
                withBlock12.Modifies = "liter";
                withBlock12.Measures = "volume";
            

            objUnit = CreateUnit();
            
                ref var withBlock13 = ref objUnit;
                withBlock13.Name = "meter";
                withBlock13.PluralName = "meters";
                withBlock13.Prefix = "m";
                withBlock13.Measures = "length";
                withBlock13.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock14 = ref objUnit;
                withBlock14.Name = "gram";
                withBlock14.PluralName = "grams";
                withBlock14.Prefix = "#,##0.####";
                withBlock14.Measures = "mass";
                withBlock14.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock15 = ref objUnit;
                withBlock15.Name = "pound";
                withBlock15.PluralName = "pounds";
                withBlock15.Modifies = "gram";
                withBlock15.Offset = 0d;
                withBlock15.Multiplier = 453.59237d;
                withBlock15.Prefix = "lb";
                withBlock15.Measures = "mass";
            

            objUnit = CreateUnit();
            
                ref var withBlock16 = ref objUnit;
                withBlock16.Name = "stone";
                withBlock16.PluralName = "stone";
                withBlock16.Modifies = "gram";
                withBlock16.Offset = 0d;
                withBlock16.Multiplier = 6350d;
                withBlock16.Prefix = "stone";
                withBlock16.Measures = "mass";
            

            objUnit = CreateUnit();
            
                ref var withBlock17 = ref objUnit;
                withBlock17.Name = "metric ton";
                withBlock17.PluralName = "metric tons";
                withBlock17.Modifies = "gram";
                withBlock17.Offset = 0d;
                withBlock17.Multiplier = 1000 * 1000;
                withBlock17.Prefix = "mtn";
                withBlock17.Measures = "mass";
            

            objUnit = CreateUnit();
            
                ref var withBlock18 = ref objUnit;
                withBlock18.Name = "ton";
                withBlock18.PluralName = "tons";
                withBlock18.Modifies = "gram";
                withBlock18.Offset = 0d;
                withBlock18.Multiplier = 907 * 1000;
                withBlock18.Prefix = "tn";
                withBlock18.Measures = "mass";
            

            objUnit = CreateUnit();
            
                ref var withBlock19 = ref objUnit;
                withBlock19.Name = "week";
                withBlock19.PluralName = "weeks";
                withBlock19.Modifies = "second";
                withBlock19.Offset = 0d;
                withBlock19.Multiplier = 60 * 60 * 24 * 7;
                withBlock19.Prefix = "wk";
                withBlock19.Measures = "time";
            

            objUnit = CreateUnit();
            
                ref var withBlock20 = ref objUnit;
                withBlock20.Name = "ounce";
                withBlock20.PluralName = "ounces";
                withBlock20.Modifies = "gram";
                withBlock20.Offset = 0d;
                withBlock20.Multiplier = 28.349523125d;
                withBlock20.Prefix = "oz";
                withBlock20.Measures = "mass";
            

            objUnit = CreateUnit();
            
                ref var withBlock21 = ref objUnit;
                withBlock21.Name = "second";
                withBlock21.PluralName = "seconds";
                withBlock21.Prefix = "s,sec";
                withBlock21.Measures = "time";
                withBlock21.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock22 = ref objUnit;
                withBlock22.Name = "ampere";
                withBlock22.PluralName = "amperes";
                withBlock22.Prefix = "A";
                withBlock22.Measures = "electric current";
                withBlock22.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock23 = ref objUnit;
                withBlock23.Name = "kelvin";
                withBlock23.PluralName = "";
                withBlock23.Prefix = "K";
                withBlock23.Measures = "thermodynamic temperature";
                withBlock23.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock24 = ref objUnit;
                withBlock24.Name = "mole";
                withBlock24.PluralName = "moles";
                withBlock24.Prefix = "mol";
                withBlock24.Measures = "amount of substance";
                withBlock24.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock25 = ref objUnit;
                withBlock25.Name = "candela";
                withBlock25.PluralName = "";
                withBlock25.Prefix = "cd";
                withBlock25.Measures = "luminous intensity";
                withBlock25.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock26 = ref objUnit;
                withBlock26.Name = "byte";
                withBlock26.PluralName = "bytes";
                withBlock26.Modifies = "bit";
                withBlock26.Multiplier = 8d;
                withBlock26.Prefix = "B";
                withBlock26.Measures = "binary data";
            

            objUnit = CreateUnit();
            
                ref var withBlock27 = ref objUnit;
                withBlock27.Name = "bit";
                withBlock27.PluralName = "bits";
                withBlock27.Prefix = "b";
                withBlock27.Measures = "binary data";
                withBlock27.IsBase = true;
            

            objUnit = CreateUnit();
            
                ref var withBlock28 = ref objUnit;
                withBlock28.Name = "parsec";
                withBlock28.PluralName = "parsecs";
                withBlock28.Prefix = "pc";
                withBlock28.Measures = "length";
                withBlock28.Modifies = "meter";
                withBlock28.Multiplier = 30.857d * Pow(10d, 12d) * 1000d;
                withBlock28.Offset = 0d;
                withBlock28.OffsetFirst = false;
            

            objUnit = CreateUnit();
                ref var withBlock29 = ref objUnit;
                withBlock29.Name = "light year";
                withBlock29.PluralName = "light years";
                withBlock29.Prefix = "ly";
                withBlock29.Measures = "length";
                withBlock29.Modifies = "meter";
                withBlock29.Multiplier = 9.4607d * Pow(10d, 15d);
                withBlock29.Offset = 0d;
                withBlock29.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock30 = ref objUnit;
                withBlock30.Name = "celsius";
                withBlock30.PluralName = "";
                withBlock30.Prefix = "C";
                withBlock30.Measures = "thermodynamic temperature";
                withBlock30.Modifies = "kelvin";
                withBlock30.Multiplier = 1d;
                withBlock30.Offset = 273.15d;
                withBlock30.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock31 = ref objUnit;
                withBlock31.Name = "fahrenheit";
                withBlock31.PluralName = "";
                withBlock31.Prefix = "F";
                withBlock31.Measures = "thermodynamic temperature";
                withBlock31.Modifies = "kelvin";
                withBlock31.Multiplier = 5d / 9d;
                withBlock31.Offset = 459.67d;
                withBlock31.OffsetFirst = true;

            objUnit = CreateUnit();
                ref var withBlock32 = ref objUnit;
                withBlock32.Name = "foot";
                withBlock32.PluralName = "feet";
                withBlock32.Prefix = "ft,'";
                withBlock32.Measures = "length";
                withBlock32.Modifies = "meter";
                withBlock32.Multiplier = 0.3048d;
                withBlock32.Offset = 0d;
                withBlock32.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock33 = ref objUnit;
                withBlock33.Name = "inch";
                withBlock33.PluralName = "inches";
                withBlock33.Prefix = "in," + '"';
                withBlock33.Measures = "length";
                withBlock33.Modifies = "meter";
                withBlock33.Multiplier = 0.0254d;
                withBlock33.Offset = 0d;
                withBlock33.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock34 = ref objUnit;
                withBlock34.Name = "pixel";
                withBlock34.PluralName = "pixels";
                withBlock34.Prefix = "px";
                withBlock34.Measures = "length";
                withBlock34.Modifies = "meter";
                withBlock34.Multiplier = 0.00026458333333333336d;
                withBlock34.Offset = 0d;
                withBlock34.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock35 = ref objUnit;
                withBlock35.Name = "point";
                withBlock35.PluralName = "points";
                withBlock35.Prefix = "pt";
                withBlock35.Measures = "length";
                withBlock35.Modifies = "meter";
                withBlock35.Multiplier = 0.00035278d;
                withBlock35.Offset = 0d;
                withBlock35.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock36 = ref objUnit;
                withBlock36.Name = "pica";
                withBlock36.PluralName = "picas";
                withBlock36.Prefix = "P";
                withBlock36.Measures = "length";
                withBlock36.Modifies = "meter";
                withBlock36.Multiplier = 0.004233d;
                withBlock36.Offset = 0d;
                withBlock36.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock37 = ref objUnit;
                withBlock37.Name = "mile";
                withBlock37.PluralName = "miles";
                withBlock37.Prefix = "mi";
                withBlock37.Measures = "length";
                withBlock37.Modifies = "meter";
                withBlock37.Multiplier = 1609.344d;
                withBlock37.Offset = 0d;
                withBlock37.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock38 = ref objUnit;
                withBlock38.Name = "yard";
                withBlock38.PluralName = "yards";
                withBlock38.Prefix = "yd";
                withBlock38.Measures = "length";
                withBlock38.Modifies = "meter";
                withBlock38.Multiplier = 0.9144d;
                withBlock38.Offset = 0d;
                withBlock38.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock39 = ref objUnit;
                withBlock39.Name = "minute";
                withBlock39.PluralName = "minutes";
                withBlock39.Prefix = "min";
                withBlock39.Measures = "time";
                withBlock39.Modifies = "second";
                withBlock39.Multiplier = 60d;
                withBlock39.Offset = 0d;
                withBlock39.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock40 = ref objUnit;
                withBlock40.Name = "hour";
                withBlock40.PluralName = "hours";
                withBlock40.Prefix = "h";
                withBlock40.Measures = "time";
                withBlock40.Modifies = "second";
                withBlock40.Multiplier = 60 * 60;
                withBlock40.Offset = 0d;
                withBlock40.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock41 = ref objUnit;
                withBlock41.Name = "day";
                withBlock41.PluralName = "days";
                withBlock41.Prefix = "d";
                withBlock41.Measures = "time";
                withBlock41.Modifies = "second";
                withBlock41.Multiplier = 60 * 60 * 24;
                withBlock41.Offset = 0d;
                withBlock41.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock42 = ref objUnit;
                withBlock42.Name = "year";
                withBlock42.PluralName = "years";
                withBlock42.Prefix = "y";
                withBlock42.Measures = "time";
                withBlock42.Modifies = "second";
                withBlock42.Multiplier = 60 * 60 * 24 * 365.25d;
                withBlock42.Offset = 0d;
                withBlock42.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock43 = ref objUnit;
                withBlock43.Name = "annus";
                withBlock43.PluralName = "annum";
                withBlock43.Prefix = "a";
                withBlock43.Measures = "time";
                withBlock43.Modifies = "second";
                withBlock43.Multiplier = 60 * 60 * 24 * 365.25d;
                withBlock43.Offset = 0d;
                withBlock43.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock44 = ref objUnit;
                withBlock44.Name = "century";
                withBlock44.PluralName = "centuries";
                withBlock44.Prefix = "C.";
                withBlock44.Measures = "time";
                withBlock44.Modifies = "second";
                withBlock44.Multiplier = 60 * 60 * 24 * 365.25d * 100d;
                withBlock44.Offset = 25 * 60 * 60 * 24;
                withBlock44.OffsetFirst = false;

            objUnit = CreateUnit();
                ref var withBlock45 = ref objUnit;
                withBlock45.Name = "millennium";
                withBlock45.PluralName = "millennia";
                withBlock45.Prefix = "M.";
                withBlock45.Measures = "time";
                withBlock45.Modifies = "second";
                withBlock45.Multiplier = 60 * 60 * 24 * 365.25d * 1000d;
                withBlock45.Offset = 0.0d;
                withBlock45.OffsetFirst = false;

            objUnit = CreateUnit();
            objUnit.Name = "aeon";
            objUnit.PluralName = "aeons";
            objUnit.Prefix = "AE.";
            objUnit.Measures = "time";
            objUnit.Modifies = "second";
            objUnit.Multiplier = 60 * 60 * 24 * 365.25d * 1000d * 1000000d;
            objUnit.Offset = 0.0d;
            objUnit.OffsetFirst = false;
            SortCategories(true);
        }

        private static void SortCategories(bool BaseUnitsFirst = false)
        {
            // ' Sorts all categories alphabetically, optionally putting all base units first

            var c1 = new UnitCollection();
            MetricUnit objUnit;
            string[] s1;
            string[] s2;
            int i;
            int c;
            int j;
            int d;
            s1 = GetCategories();
            c = s1.Length - 1;

            // ' each category starts with its base unit, and then modifying units come next alphabetically, by category alphabetically
            if (BaseUnitsFirst == false)
            {
                var loopTo = c;
                for (i = 0; i <= loopTo; i++)
                {
                    s2 = GetUnitNames(s1[i]);
                    d = s2.Length - 1;
                    var loopTo1 = d;
                    for (j = 0; j <= loopTo1; j++)
                    {
                        objUnit = FindUnit(s2[j], s1[i]);
                        if (objUnit.IsBase == true)
                        {
                            c1.Add(objUnit);
                            break;
                        }
                    }

                    d = s2.Length - 1;
                    var loopTo2 = d;
                    for (j = 0; j <= loopTo2; j++)
                    {
                        objUnit = FindUnit(s2[j], s1[i]);
                        if (objUnit.IsBase == false)
                            c1.Add(objUnit);
                    }
                }

                units = c1;
                return;
            }
            else
            {
                // ' this is the alternative way, listing all base units by category alphabetically, first, then all other units by category alphabetically
                var loopTo3 = c;
                for (i = 0; i <= loopTo3; i++)
                {
                    s2 = GetUnitNames(s1[i]);
                    d = s2.Length - 1;
                    var loopTo4 = d;
                    for (j = 0; j <= loopTo4; j++)
                    {
                        objUnit = FindUnit(s2[j], s1[i]);
                        if (objUnit.IsBase == true)
                        {
                            c1.Add(objUnit);
                            break;
                        }
                    }
                }

                var loopTo5 = c;
                for (i = 0; i <= loopTo5; i++)
                {
                    s2 = GetUnitNames(s1[i]);
                    d = s2.Length - 1;
                    var loopTo6 = d;
                    for (j = 0; j <= loopTo6; j++)
                    {
                        objUnit = FindUnit(s2[j], s1[i]);
                        if (objUnit.IsBase == false)
                            c1.Add(objUnit);
                    }
                }

                units = c1;
                return;
            }
        }


        public static void AddUnit(MetricUnit unit)
        {
            units.Add(unit);
        }

        public static MetricUnit CreateUnit(string measures = "", string name = "", string pluralName = "", string prefix = "", string modifies = "", double multiplier = 0.0d, double offset = 0.0d, bool offsetFirst = false, bool isBase = false)
        {
            var b = new MetricUnit();

            b.Measures = measures;
            b.IsBase = isBase;
            b.Name = name;
            b.PluralName = pluralName;
            b.Prefix = prefix;
            b.Modifies = modifies;
            b.Multiplier = multiplier;
            b.Offset = offset;
            b.OffsetFirst = offsetFirst;

            units.Add(b);

            return b;
        }

        public static string[] GetCategories()
        {
            string[] s = null;

            int c = -1;

            foreach (MetricUnit u in units)
            {
                if (c == -1)
                {
                    s = new string[1];
                    s[0] = TitleCase(u.Measures);
                    c = 1;
                }
                else if (s.Contains(TitleCase(u.Measures)) == false)
                {
                    Array.Resize(ref s, c + 1);
                    s[c] = TitleCase(u.Measures);
                    c += 1;
                }
            }

            Array.Sort(s);
            return s;
        }

        [Description("Get all unit names for a category.")]
        public static string[] GetUnitNames(string Category, bool ExcludeBaseUnit = false)
        {
            string[] c = null;
            int n = 0;
            foreach (MetricUnit u in units)
            {
                if ((u.Measures.ToLower() ?? "") == (Category.ToLower() ?? "") & (u.IsBase == false | ExcludeBaseUnit == false))
                {
                    Array.Resize(ref c, n + 1);
                    c[n] = TitleCase(u.Name);
                    n += 1;
                }
            }

            Array.Sort(c);
            return c;
        }

        [Description("Get all base unit names.")]
        public static string[] GetBaseUnitNames()
        {
            string[] c = null;
            int n = 0;
            foreach (MetricUnit u in units)
            {
                if (u.IsBase == true)
                {
                    Array.Resize(ref c, n + 1);
                    c[n] = TitleCase(u.Name);
                    n += 1;
                }
            }

            Array.Sort(c);
            return c;
        }

        public static bool HasCategory(string Category)
        {
            foreach (MetricUnit u in units)
            {
                if ((u.Measures.ToLower() ?? "") == (Category.ToLower() ?? ""))
                    return true;
            }

            return false;
        }

        [Description("Get all base units for all categories.")]
        public static UnitCollection GetBaseUnits()
        {
            var c = new UnitCollection();
            foreach (MetricUnit u in units)
            {
                if (u.IsBase == true)
                    c.Add((MetricUnit)u.Clone());
            }

            return c;
        }

        [Description("Get all units for a category.")]
        public static UnitCollection GetUnits(string Category = "")
        {
            var uc = new UnitCollection();
            MetricUnit[] a;
            int i;
            int c;
            a = units.InnerArray;
            c = a.Length - 1;
            Category = TitleCase(Category);
            var loopTo = c;
            for (i = 0; i <= loopTo; i++)
            {
                if ((a[i].Measures ?? "") == (Category ?? "") | string.IsNullOrEmpty(Category))
                {
                    uc.Add((MetricUnit)a[i].Clone());
                }
            }

            return uc;
        }

        [Description("Get all units for a category as an array.")]
        public static MetricUnit[] GetUnitsArray(string Category = "")
        {
            MetricUnit[] a;
            int i;
            int c;
            MetricUnit[] b = null;
            int n = 0;
            a = units.InnerArray;
            c = a.Length - 1;
            Category = Category.ToLower();
            var loopTo = c;
            for (i = 0; i <= loopTo; i++)
            {
                if (NoSpace(a[i].Measures.ToLower()) == Category | string.IsNullOrEmpty(Category))
                {
                    Array.Resize(ref b, n + 1);
                    b[n] = (MetricUnit)a[i].Clone();
                    n += 1;
                }
            }

            return b;
        }

        [Description("Get the base unit for a specific category.")]
        public static MetricUnit GetBaseUnit(string Category)
        {
            foreach (MetricUnit u in units)
            {
                if (u.IsBase == true & (u.Measures.ToLower() ?? "") == (Category.ToLower() ?? ""))
                    return (MetricUnit)u.Clone();
            }

            return null;
        }

        [Description("Find an exact unit.")]
        public static MetricUnit FindUnit(string Unit, string MustMeasure = "")
        {
            string[] s;
            int i;
            int c;
            foreach (MetricUnit u in units)
            {
                if ((u.Measures.ToLower() ?? "") == (MustMeasure.ToLower() ?? "") | string.IsNullOrEmpty(MustMeasure))
                {
                    if ((u.Name.ToLower() ?? "") == (Unit.ToLower() ?? ""))
                        return (MetricUnit)u.Clone();
                    if ((u.PluralName.ToLower() ?? "") == (Unit.ToLower() ?? ""))
                        return (MetricUnit)u.Clone();
                    s = Split(u.Prefix, ",");
                    c = s.Length - 1;
                    var loopTo = c;
                    for (i = 0; i <= loopTo; i++)
                    {
                        if ((s[i] ?? "") == (Unit ?? ""))
                            return (MetricUnit)u.Clone();
                    }
                }
            }

            return null;
        }
    }

    [DefaultProperty("Item")]
    public class UnitCollection : CollectionBase
    {
        public class UnitCollectionEventArgs : EventArgs
        {
            private MetricUnit _Item = null;
            private bool _Cancel = false;

            public bool Cancel
            {
                get
                {
                    return _Cancel;
                }

                set
                {
                    _Cancel = value;
                }
            }

            public UnitCollectionEventArgs(MetricUnit item)
            {
                _Item = item;
            }

            public MetricUnit Item
            {
                get
                {
                    return _Item;
                }
            }
        }

        protected MetricTool _Parent;

        public event ObjectAddEventHandler ObjectAdd;

        public delegate void ObjectAddEventHandler(object sender, UnitCollectionEventArgs e);

        public event ObjectRemoveEventHandler ObjectRemove;

        public delegate void ObjectRemoveEventHandler(object sender, UnitCollectionEventArgs e);

        public event ClearItemsEventHandler ClearItems;

        public delegate void ClearItemsEventHandler(object sender, UnitCollectionEventArgs e);

        [Browsable(false)]
        public MetricUnit[] InnerArray
        {
            get
            {
                return (MetricUnit[])InnerList.ToArray(typeof(MetricUnit));
            }
        }

        [Browsable(false)]
        public MetricTool Parent
        {
            get
            {
                return _Parent;
            }
        }

        public MetricUnit this[int index]
        {
            get
            {
                return (MetricUnit)List[index];
            }

            set
            {
                List[index] = value;
            }
        }

        public new void Clear()
        {
            UnitCollectionEventArgs e;
            e = new UnitCollectionEventArgs(null);
            ClearItems?.Invoke(this, e);
            if (e.Cancel == true)
                return;
            List.Clear();
        }

        public int Add(MetricUnit value)
        {
            int i;
            var e = new UnitCollectionEventArgs(value);
            i = List.Add(value);
            ObjectAdd?.Invoke(this, e);
            if (e.Cancel == true)
            {
                List.Remove(value);
                i = -1;
            }

            return i;
        }

        public int IndexOf(MetricUnit value)
        {
            return List.IndexOf(value);
        }

        public void Insert(int index, MetricUnit value)
        {
            int i = List.Add(value);
            var e = new UnitCollectionEventArgs(value);
            ObjectAdd?.Invoke(this, new UnitCollectionEventArgs(value));
            if (e.Cancel == true)
                return;
            List.Insert(index, value);
        }

        public void Remove(MetricUnit value)
        {
            UnitCollectionEventArgs e;
            e = new UnitCollectionEventArgs(value);
            ObjectRemove?.Invoke(this, e);
            if (e.Cancel == true)
                return;
            List.Remove(value);
        }

        public bool Contains(MetricUnit value)
        {
            return List.Contains(value);
        }

        protected override void OnValidate(object value)
        {
            if (!typeof(MetricUnit).IsAssignableFrom(value.GetType()))
            {
                throw new ArgumentException("value must be implement MetricUnit.", "value");
            }
        }

        public UnitCollection(MetricTool parent)
        {
            _Parent = parent;
        }

        public UnitCollection()
        {
        }
    }
}



















